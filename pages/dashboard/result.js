import React, { useEffect, useState } from "react";
import { useSession, getSession } from "next-auth/react";
import { useSelector, useDispatch } from "react-redux";
import axios from "axios";
import cookie from "js-cookie";
import {
  Alert,
  AlertTitle,
  Box,
  Button,
  Dialog,
  DialogActions,
  DialogContent,
  DialogContentText,
  DialogTitle,
  Snackbar,
  TextField,
  Typography,
} from "@mui/material";
import Image from "next/image";
import { useRouter } from "next/router";
import * as XLSX from "xlsx/xlsx";
import { v4 as uuidv4 } from "uuid";
import FileUploadOutlinedIcon from "@mui/icons-material/FileUploadOutlined";
import SaveOutlinedIcon from "@mui/icons-material/SaveOutlined";
import EditProductDialog from "../../components/dashboard/product/EditProductDialog.js";
import ProductTable from "../../components/dashboard/product/ProductTable";
import ImageRecTable from "../../components/dashboard/product/ImageRecTable.js";
import {
  excelExport,
  createCurrentRowData,
} from "../../components/helper/dashboard/productHelper";
import { setImageRec, setPaid, setPremium } from "../../store/uploadSlice";
import "../../components/dashboard/product/product.css";
import SnackbarNotifier from "../../components/helper/dashboard/snackbarNotifier";
import PersonaTable from "../../components/dashboard/product/PersonaTable.js";
import ImagePersonaTable from "../../components/dashboard/product/ImagePersonaTable.js";
import { useWarning } from "../../context/WarningContext.js";
import WarningBox from "../..//components/helper/WarningBox.js";
import ShareOutlinedIcon from "@mui/icons-material/ShareOutlined";
import ShareDocModal from "../../components/dashboard/document/shareDocModal.js";
import { POST_SAVE_PRODUCTS } from "../../utils/apiEndpoints.js";
import { Download } from "@mui/icons-material";
import jsPDF from "jspdf";
import BlogDownloadDialog from "../../components/dashboard/results/BlogDownloadDialog.js";
import { getFormattedTimestamp } from "../../utils/timestampUtils.js";

const products = ({ user }) => {
  const { data: session, status, update } = useSession();
  const dispatch = useDispatch();
  const router = useRouter();
  const [openShareModal, setOpenShareModal] = useState(false);
  const { getFileName, getBlogFileName, isSelected, eyeClick, userId } =
    router.query;
  const [selectedProduct, setSelectedProduct] = useState([]);
  const [isGenerateErrorOpen, setIsGenerateErrorOpen] = useState(false);
  const [isValidColumnName, setIsValidColumnName] = useState(false);
  //To add seo and taxonomy in result table if it was opted in enhancement page
  const [isSEO, setIsSEO] = useState(false);
  const [isTaxonomy, setIsTaxonomy] = useState(false);
  const [currentProductIndex, setCurrentProductIndex] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [editableRow, setEditableRow] = useState(null);
  //To save results generated by API
  const [newRow, setNewRow] = useState([]);
  const [limitReached, setLimitReached] = useState(false);
  const [rowData, setRowData] = useState({});
  const [openEditProductDialog, setOpenEditProductDialog] = useState(false);
  const [isValidProduct, setIsValidProduct] = useState(false);
  // used to check whether auto save is completed or not in edit product popup
  const [isBlogDownloadOpen, setIsBlogDownloadOpen] = useState(false);
  const [blogData, setBlogData] = useState(null);

  const { showWarning } = useWarning();

  let isFreeBasicUser =
    user?.planCode?.startsWith("chgpt-basic") ||
    user?.planCode?.startsWith("chgpt-free");

  const [autoSave, setAutoSave] = useState(false);
  const [snackbarState, setSnackbarState] = useState({
    open: false,
    message: "",
    severity: "success",
  });

  const handleSnackbarClose = () => {
    setIsValidColumnName(false);
    setIsGenerateErrorOpen(false);
  };

  const activateSnackbar = (message, severity = "success") => {
    setSnackbarState({
      open: true,
      message: message,
      severity: severity,
    });
  };
  //funtion to get user Details
  useEffect(() => {
    if (session?.user && !session.user.terms) {
      const rememberMe = cookie.get("rememberMe");

      if (session.user.terms !== rememberMe) {
        update({ ...session, terms: rememberMe });
        session.user = { ...session.user, terms: rememberMe };
      }
    }

    if (user?.newUser) {
      router.push({
        pathname: "/dashboard/profile",
        query: {
          profile_message: "Please update your profile to continue",
        },
      });
    }

    if (user?.id_token) {
      axios
        .get(
          process.env.NEXT_PUBLIC_DASHBOARD_BASE_URL +
            "/dashboard/profile/get/user",
          {
            headers: {
              Authorization: user.id_token,
            },
          }
        )
        .then((response) => {
          if (response?.data?.monthlyLimit <= 0) {
            setLimitReached(true);
          }

          if (response?.data?.paidUser === true) {
            dispatch(setPaid(true));

            const planCode = response?.data?.planCode || "";
            if (
              planCode === "chgpt-premium" ||
              planCode.startsWith("chgpt-enterprise")
            ) {
              dispatch(setPremium(true));
            }

            if (planCode.startsWith("chgpt-enterprise")) {
              dispatch(setImageRec(true));
            }
          }
        })
        .catch((error) => {
          console.error("Error fetching user profile:", error);
        });
    }
  }, [status]);

  const handleDownloadBlog = () => {
    setIsBlogDownloadOpen(true);
  };
  const handleDownloadBlogText = () => {
    // Prepare Text File content
    let textContent = "";

    // Title
    textContent += `${blogData?.title || ""}\n\n`;

    // Introduction
    textContent += `\n${blogData?.introduction || ""}\n\n`;

    // Sections
    blogData?.sections?.forEach((section) => {
      textContent += `${section?.subheading}\n`;
      section?.paragraphs?.forEach((paragraph) => {
        textContent += `${paragraph}\n`;
      });
      textContent += "\n";
    });

    // Conclusion
    textContent += `Conclusion:\n${blogData?.conclusion || ""}\n\n`;

    // Tips
    textContent += `Tips:\n`;
    blogData?.tips?.forEach((tip, index) => {
      textContent += `${index + 1}. ${tip}\n`;
    });

    // Download TXT
    const blob = new Blob([textContent], { type: "text/plain" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");

    a.href = url;

    const timestamp = getFormattedTimestamp();

    const filename = `Blog-${
      blogData?.title?.replace(/\s+/g, "_") || "blog"
    }-${timestamp}.txt`;
    a.download = filename;
    a.click();

    a.remove();
    URL.revokeObjectURL(url);
  };
  const handleDownloadBlogPdf = () => {
    const doc = new jsPDF();

    const margin = 10;
    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();

    const contentWidth = pageWidth - 2 * margin;

    // Title
    const title = blogData?.title || "";
    doc.setFont("helvetica", "bold");
    doc.setFontSize(16);
    let y = margin;
    const lineHeight = 8;

    const lines = doc.splitTextToSize(title, contentWidth);

    lines.forEach((line) => {
      if (y + lineHeight > pageHeight - margin) {
        doc.addPage();
        y = margin;
      }
      doc.text(line, margin, y);
      y += lineHeight;
    });

    // Introduction
    const intro = blogData?.introduction || "";
    doc.setFont("helvetica", "normal");
    doc.setFontSize(12);

    const introLines = doc.splitTextToSize(intro, contentWidth);
    introLines.forEach((line) => {
      if (y + lineHeight > pageHeight - margin) {
        doc.addPage();
        y = margin;
      }
      doc.text(line, margin, y);
      y += lineHeight;
    });

    y += 3;

    // Sections
    blogData?.sections?.forEach((section) => {
      // Subheading
      doc.setFont("helvetica", "bold");
      doc.setFontSize(14);
      const subheadingLines = doc.splitTextToSize(
        section.subheading,
        contentWidth
      );
      subheadingLines.forEach((line) => {
        if (y + lineHeight > pageHeight - margin) {
          doc.addPage();
          y = margin;
        }
        doc.text(line, margin, y);
        y += lineHeight;
      });

      // Paragraphs
      doc.setFont("helvetica", "normal");
      doc.setFontSize(12);
      section.paragraphs.forEach((paragraph) => {
        const paraLines = doc.splitTextToSize(paragraph, contentWidth);
        paraLines.forEach((line) => {
          if (y + lineHeight > pageHeight - margin) {
            doc.addPage();
            y = margin;
          }
          doc.text(line, margin, y);
          y += lineHeight;
        });
        y += 1; // space between paragraphs
      });

      y += 3; // space between sections
    });

    // Conclusion
    const conclusionHeading = "Conclusion";
    doc.setFont("helvetica", "bold");
    doc.setFontSize(14);

    const conclusionHeadingLines = doc.splitTextToSize(
      conclusionHeading,
      contentWidth
    );
    conclusionHeadingLines.forEach((line) => {
      if (y + lineHeight > pageHeight - margin) {
        doc.addPage();
        y = margin;
      }
      doc.text(line, margin, y);
      y += lineHeight;
    });

    const conclusion = blogData?.conclusion || "";
    doc.setFont("helvetica", "normal");
    doc.setFontSize(12);

    const conclusionLines = doc.splitTextToSize(conclusion, contentWidth);
    conclusionLines.forEach((line) => {
      if (y + lineHeight > pageHeight - margin) {
        doc.addPage();
        y = margin;
      }
      doc.text(line, margin, y);
      y += lineHeight;
    });

    y += 3;

    // Tips
    const tipsHeading = "Tips";
    doc.setFont("helvetica", "bold");
    doc.setFontSize(14);

    const tipsHeadingLines = doc.splitTextToSize(tipsHeading, contentWidth);
    tipsHeadingLines.forEach((line) => {
      if (y + lineHeight > pageHeight - margin) {
        doc.addPage();
        y = margin;
      }
      doc.text(line, margin, y);
      y += lineHeight;
    });

    blogData?.tips?.forEach((tip) => {
      doc.setFont("helvetica", "normal");
      doc.setFontSize(12);
      const paraLines = doc.splitTextToSize(tip, contentWidth);
      paraLines.forEach((line) => {
        if (y + lineHeight > pageHeight - margin) {
          doc.addPage();
          y = margin;
        }
        doc.text(line, margin, y);
        y += lineHeight;
      });
    });

    const timestamp = getFormattedTimestamp();

    const filename = `Blog-${
      blogData?.title?.replace(/\s+/g, "_") || "blog"
    }-${timestamp}.pdf`;

    doc.save(filename);
  };

  useEffect(() => {
    if (currentProductIndex !== null) {
      const currentRow = newRow[currentProductIndex];

      // Ensure all properties are carried over correctly
      const value = currentRow
        ? {
            ...currentRow,
            ...createCurrentRowData(currentRow, isSelected, true),
          }
        : {};

      setRowData(value);
    }
  }, [currentProductIndex]);
  // Run effect when index or newRow changes.

  const handleTextFieldChange = (event) => {
    const { name, value } = event.target;
    setRowData({
      ...rowData,
      [name]: value,
    });
  };

  const extractfirstTenRows = async (encoded_name) => {
    if (!encoded_name) {
      setIsLoading(false);
      return;
    }
    const config = {
      headers: {
        Authorization: user?.id_token,
      },
    };
    try {
      let response;
      if (isSelected === "image") {
        const endpoint =
          eyeClick === "true"
            ? `/img/image/result/v2?fileName=${encoded_name}`
            : `/img/image/result?fileName=${encoded_name}`;
        response = await fetch(
          process.env.NEXT_PUBLIC_BASE_URL + endpoint,
          config
        );
      } else if (isSelected == "product") {
        const endpoint =
          eyeClick === "true"
            ? `/standalone/fetch/result/v3?fileName=${encoded_name}&userId=${userId}`
            : `/standalone/fetch/result/v3?fileName=${encoded_name}&userId=${user?.user_id}`;
        response = await axios.get(
          process.env.NEXT_PUBLIC_BASE_URL + endpoint,
          config
        );
      }
      if (response.status === 400) {
        setIsLoading(false);
        activateSnackbar("Task Failed. Please retry!", "error");
      }
      const contentType = response.headers.get("content-type");
      if (contentType.includes("application/json")) {
        if (response.status !== 200) {
          setIsLoading(false);
          activateSnackbar(
            "Image source not readable. Could you please upload a different image?",
            "error"
          );
          // setErrorMsg(jsonData.message);
        } else {
          setNewRow(response?.data);
          setIsLoading(false);
          setIsSEO(response?.data[0].seo_meta_title ? true : false);
          setIsTaxonomy(response?.data[0].Taxonomy ? true : false);
        }
      } else if (
        contentType.includes(
          "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        )
      ) {
        const blobData = await response.blob();
        const reader = new FileReader();
        reader.onload = (event) => {
          const data = new Uint8Array(event.target.result);
          const workbook = XLSX.read(data, { type: "array" });
          const sheetName = workbook.SheetNames[0];
          const sheet = workbook.Sheets[sheetName];
          const jsonData = XLSX.utils.sheet_to_json(sheet, {
            header: 1,
            defval: "",
          });
          const keyValues = jsonData.shift();
          const mappedData = jsonData.map((row) => {
            return row.reduce((obj, value, index) => {
              if (keyValues[index] === "input_keywords") {
                obj["keywords"] = value;
              } else if (keyValues[index] === "input_brand") {
                obj["brand"] = value;
              } else {
                if (isSelected !== "image" && keyValues[index] !== "id") {
                  obj[keyValues[index]] = value;
                } else if (
                  isSelected === "image" &&
                  keyValues[index] === "id"
                ) {
                  obj["image_id"] = value;
                } else {
                  obj[keyValues[index]] = value;
                }
              }
              obj.id = uuidv4();
              return obj;
            }, {});
          });
          if (mappedData.length > 0) {
            setIsSEO(mappedData[0].seo_meta_title ? true : false);
            setIsTaxonomy(mappedData[0].Taxonomy ? true : false);
          }

          setNewRow(mappedData);
          setIsLoading(false);
        };
        reader.readAsArrayBuffer(blobData);
      } else {
        throw new Error("Unsupported content type.");
      }
    } catch (error) {
      setIsLoading(false);
      activateSnackbar("Task Failed. Please retry!", "error");
    }
  };

  useEffect(() => {
    if (getFileName !== "") {
      const encoded_name = getFileName;
      extractfirstTenRows(encoded_name);
    }
  }, [getFileName]);

  useEffect(() => {
    const fetchBlogData = async () => {
      try {
        const response = await axios.get(
          process.env.NEXT_PUBLIC_BASE_URL +
            `/standalone/get/blog?filename=${getBlogFileName}`,
          {
            headers: {
              Authorization: user?.id_token,
            },
          }
        );
        setBlogData(response?.data?.blog);
      } catch (error) {
        activateSnackbar("Failed to fetch blog. Please retry!", "error");
      }
    };

    if (getBlogFileName) fetchBlogData();
  }, [getBlogFileName]);

  // haandles saving the document and opening the share modal
  const handleOpenShareModal = () => {
    if (newRow.length == 0) {
      activateSnackbar("Please Select a file to share", "error");
    } else {
      setOpenShareModal(true);
    }
  };

  const handleCloseShareModal = () => setOpenShareModal(false);

  const handleOpenShareDialog = async () => {
    if (newRow.length === 0) {
      console.error("Products array is empty. Cannot save document.");
      return;
    }

    // Iterate through the newRow array to add the optional_keywords field
    const updatedProducts = newRow.map((product) => ({
      ...product,
      optional_keywords: product["optional_keywords"],
    }));

    const data = {
      filename: router?.query?.getFileName,
      username: user?.name || "NA",
      products: updatedProducts,
      type:
        isSelected === "product"
          ? "PRODUCT_RESULT_DOCUMENT"
          : "IMAGE_RECOGNITION_RESULT_DOCUMENT",
    };

    try {
      const response = await axios.post(
        process.env.NEXT_PUBLIC_DASHBOARD_BASE_URL + POST_SAVE_PRODUCTS,
        data,
        {
          headers: {
            Authorization: user.id_token,
          },
        }
      );
      if (response?.data?.status == true) {
        activateSnackbar("Document is successfully saved!");

        setOpenShareModal(true);
      } else {
        activateSnackbar(response?.data?.message, "error");
      }
    } catch (error) {
      console.error("Error while Saving Document", error);
    }
  };

  //Save documents
  const [openSaveDialog, setOpenSaveDialog] = useState(false);
  const [fileName, setFileName] = useState("");
  const [saveFileName, setSaveFileName] = useState(
    "Example_Product_Upload.xls"
  );
  const handleOpenSaveDialog = () => {
    let contentToAdd = "Results";
    const saveFile = saveFileName.startsWith(contentToAdd)
      ? saveFileName
      : `${contentToAdd}-${saveFileName}`;
    setSaveFileName(saveFile);
    handleRowClick(null);
    setOpenSaveDialog(true);
  };
  const handleCloseSaveDialog = () => {
    setOpenEditProductDialog(false);
    setOpenSaveDialog(false);
  };

  const handleSaveDocument = async () => {
    if (newRow.length === 0) {
      console.error("Products array is empty. Cannot save document.");
      return;
    }
    // Iterate through the newRow array to add the optional_keywords field
    const updatedProducts = newRow.map((product) => {
      const { Taxonomy, ...rest } = product;

      return {
        ...rest,
        optional_keywords: product["optional_keywords"],
        taxonomy: Taxonomy,
      };
    });

    const data = {
      filename: fileName,
      username: user?.name || "NA",
      products: updatedProducts,
      type:
        isSelected === "product"
          ? "PRODUCT_RESULT_DOCUMENT"
          : "IMAGE_RECOGNITION_RESULT_DOCUMENT",
    };

    try {
      const response = await axios.post(
        process.env.NEXT_PUBLIC_DASHBOARD_BASE_URL + POST_SAVE_PRODUCTS,
        data,
        {
          headers: {
            Authorization: user.id_token,
          },
        }
      );
      if (response?.data?.status == true) {
        activateSnackbar("Document is successfully saved!");
      } else {
        activateSnackbar(response?.data?.message, "error");
      }
    } catch (error) {
      console.error("Error while Saving Document", error);
    }

    handleCloseSaveDialog();
  };

  // function related to table operation
  const handleRowClick = (row, cellIndex) => {
    setCurrentProductIndex(cellIndex);

    // Make a shallow copy of the row to avoid mutating the original object
    const rowCopy = { ...row?.original };

    setEditableRow(rowCopy); // Use copy to avoid mutation

    if (row !== null) {
      setRowData(rowCopy); // Use copy for rowData as well
      setOpenEditProductDialog(true);
    }
  };

  const generateExcel = () => {
    const newArray = newRow.map((obj) => {
      const {
        id,
        description,
        relevant_keywords,
        original,
        input_brand,
        ...rest
      } = obj;
      let filteredObj;
      if (isFreeBasicUser === false && isSEO === false) {
        // Remove seo_meta_title and seo_meta_description
        const { seo_meta_title, seo_meta_description, ...filteredRest } = rest;
        // return filteredRest;
        filteredObj = filteredRest;
      } else {
        filteredObj = rest;
      }
      if (isSelected === "image") {
        return {
          image_id: filteredObj.image_id || "",
          item: filteredObj.item || "",
          optional_keywords: filteredObj.optional_keywords || "",
          image_url: filteredObj.image_url || "",
          labels: filteredObj.labels || "",
          alt_text: filteredObj["alt-text"] || "",
          what_is_item: filteredObj["What is Item"] || "",
          persona: filteredObj.persona || "",
          channel: filteredObj.channel || "",
          product_description: filteredObj["Item Description"] || "",
          feature_bullet1: filteredObj.Feature_Bullet1 || "",
          feature_bullet2: filteredObj.Feature_Bullet2 || "",
          feature_bullet3: filteredObj.Feature_Bullet3 || "",
          feature_bullet4: filteredObj.Feature_Bullet4 || "",
          feature_bullet5: filteredObj.Feature_Bullet5 || "",
          seo_meta_title: filteredObj.seo_meta_title || "",
          seo_meta_description: filteredObj.seo_meta_description || "",
        };
      }
      const finalObj = {
        product_id: filteredObj.product_id || "",
        channel: filteredObj.channel || "",
        persona: filteredObj.persona || "",
        product_name: filteredObj.product_name || "",
        product_description: filteredObj.product_description || "",
        feature_bullet1: filteredObj.feature_bullet1 || "",
        feature_bullet2: filteredObj.feature_bullet2 || "",
        feature_bullet3: filteredObj.feature_bullet3 || "",
        feature_bullet4: filteredObj.feature_bullet4 || "",
        feature_bullet5: filteredObj.feature_bullet5 || "",
        seo_meta_title: filteredObj.seo_meta_title || "",
        seo_meta_description: filteredObj.seo_meta_description || "",
        Taxonomy: filteredObj.Taxonomy || "",
        persona_match: filteredObj.persona_match || "",
        persona_suggestion: filteredObj.persona_suggestion || "",
        // compliance: filteredObj.compliance || "",
        status: filteredObj.status || "",
        brand: filteredObj.brand || "",
        input_keywords: filteredObj.input_keywords || "",
        seo_keywords: filteredObj.seo_keywords || "",
        exclude_keywords: filteredObj.exclude_keywords || "",
        input_product_description: filteredObj.input_product_description || "",
        input_feature_bullet1: filteredObj.input_feature_bullet1 || "",
        input_feature_bullet2: filteredObj.input_feature_bullet2 || "",
      };

      if (filteredObj.compliance && filteredObj.compliance.trim() !== "") {
        finalObj.compliance = filteredObj.compliance;
      }
      return finalObj;
    });
    if (newArray.length > 0) {
      excelExport(newArray);
    }
  };

  useEffect(() => {
    handleSaveDocument();
    handleCloseSaveDialog();
  }, [fileName]);

  return (
    <>
      {isBlogDownloadOpen && (
        <BlogDownloadDialog
          open={isBlogDownloadOpen}
          onClose={() => setIsBlogDownloadOpen(false)}
          handleDownloadBlogText={handleDownloadBlogText}
          handleDownloadBlogPdf={handleDownloadBlogPdf}
        />
      )}
      <Box>
        <Typography
          className="content"
          variant="h6"
          fontWeight="bold"
          color="#000"
          sx={{
            fontSize: {
              sx: "24px !important",
              md: "32px !important",
            },
          }}
        >
          Product Results
        </Typography>
      </Box>
      <Box className="product-pg-content-div">
        <Typography className="product-pg-content">
          You can edit the results on this page before Saving and Exporting
        </Typography>
      </Box>
      {showWarning && <WarningBox />}
      {/* Limit Reached box */}
      {limitReached && (
        <Box className="limit-reached-box">
          <Typography variant="" fontWeight="bold">
            Limit Reached
          </Typography>
          <Typography>
            You have reached your monthly limit. Please visit the pricing page
            to upgrade your plan.
          </Typography>
          <Button
            disableFocusRipple
            variant="contained"
            className="upgreade-btn"
            onClick={() => {
              router.push({
                pathname: "/dashboard/pricing",
              });
            }}
            sx={{
              marginTop: "10px",
              backgroundColor: "#ee071b",
              // borderRadius: "3px",
              borderColor: "#ee071b",
              "&:hover": {
                backgroundColor: "#ee071b",
                borderColor: "#ee071b",
              },
            }}
          >
            Upgrade Plan
          </Button>
        </Box>
      )}

      {isLoading && (
        <div
          style={{
            position: "fixed",
            top: "50%",
            left: "50%",
            transform: "translate(-50%, -50%)",
          }}
        >
          <Image
            src="/dashboard/loaderOverskeleton.gif"
            width={150}
            height={150}
            alt="loading..."
          ></Image>
        </div>
      )}

      {/* product table operation button section  */}
      {!isLoading && (
        <Box
          sx={{
            marginBottom: "5px",
            gap: "6px",
            display: "flex",
            justifyContent: "end",
            marginTop: "25px",
          }}
        >
          <Box className="export-save-btns">
            <Button
              disableFocusRipple
              variant="outlined"
              onClick={handleDownloadBlog}
              disabled={!blogData}
              sx={{
                "&.Mui-disabled": {
                  background: "#FFFFFF !important",
                  borderColor: "#ABABAB",
                  color: "#ABABAB",
                },
                "&:hover": {
                  color: "#2E4770",
                  backgroundColor: "#F9F9FF",
                  borderColor: "#6077A4",
                },
                marginRight: "6px",
                textTransform: "none",
                borderRadius: "5px",
                backgroundColor: "#FFFFFF",
                borderColor: "#C6C6C6",
                color: "#474747",
                fontWeight: 500,
                boxShadow: "none",
                padding: { xs: "6px 9px", md: "6px 16px" },
              }}
            >
              <Download />
              <Typography sx={{ marginLeft: "4px" }}> Download Blog</Typography>
            </Button>
            <Button
              disableFocusRipple
              variant="outlined"
              onClick={handleOpenShareDialog}
              disabled={newRow.length === 0}
              sx={{
                "&.Mui-disabled": {
                  background: "#FFFFFF !important",
                  borderColor: "#ABABAB",
                  color: "#ABABAB",
                },
                "&:hover": {
                  color: "#2E4770",
                  backgroundColor: "#F9F9FF",
                  borderColor: "#6077A4",
                },
                marginRight: "6px",
                textTransform: "none",
                borderRadius: "5px",
                backgroundColor: "#FFFFFF",
                borderColor: "#C6C6C6",
                color: "#474747",
                fontWeight: 500,
                boxShadow: "none",
                padding: { xs: "6px 9px", md: "6px 16px" },
              }}
            >
              <ShareOutlinedIcon />
              <Typography sx={{ marginLeft: "4px" }}> Share</Typography>
            </Button>
            <ShareDocModal
              user={user}
              fileList={[router?.query?.getFileName]}
              userIds={[user?.user_id]}
              isOpen={openShareModal}
              onClose={handleCloseShareModal}
              isAllUserSame={true}
            />
            <Button
              disableFocusRipple
              variant="contained"
              onClick={generateExcel}
              sx={{
                "&.Mui-disabled": {
                  background: "#FFFFFF !important",
                  borderColor: "#ABABAB",
                  color: "#ABABAB",
                },
                "&:hover": {
                  color: "#2E4770",
                  backgroundColor: "#F9F9FF",
                  borderColor: "#6077A4",
                },
                marginRight: "6px",
                textTransform: "none",
                borderRadius: "5px",
                backgroundColor: "#FFFFFF",
                borderColor: "#C6C6C6",
                color: "#474747",
                fontWeight: 500,
                boxShadow: "none",
                padding: { xs: "6px 9px", md: "6px 16px" },
              }}
            >
              <FileUploadOutlinedIcon />
              <Typography sx={{ marginLeft: "4px" }}>Export</Typography>
            </Button>
            <Button
              disableFocusRipple
              variant="outlined"
              onClick={handleOpenSaveDialog}
              disabled={newRow.length === 0}
              sx={{
                "&.Mui-disabled": {
                  background: "#FFFFFF !important",
                  borderColor: "#ABABAB",
                  color: "#ABABAB",
                },
                "&:hover": {
                  color: "#2E4770",
                  backgroundColor: "#F9F9FF",
                  borderColor: "#6077A4",
                },
                marginRight: "6px",
                textTransform: "none",
                borderRadius: "5px",
                backgroundColor: "#FFFFFF",
                borderColor: "#C6C6C6",
                color: "#474747",
                fontWeight: 500,
                boxShadow: "none",
                padding: { xs: "6px 9px", md: "6px 16px" },
              }}
            >
              <SaveOutlinedIcon />
              <Typography sx={{ marginLeft: "4px" }}> Save</Typography>
            </Button>
          </Box>
          <Button
            disableFocusRipple
            variant="contained"
            sx={{
              "&.Mui-disabled": {
                background: "#777777 !important",
                borderColor: "#777777",
                color: "#C6C6C6",
              },
              "&:hover": {
                color: "#FCFCFC",
                backgroundColor: "#163058",
                borderColor: "#163058",
              },
              padding: { xs: "6px 9px", md: "6px 16px" },
              fontSize: { xs: "12px", md: "14px" },
              marginRight: "6px",
              textTransform: "none",
              borderRadius: "5px",
              backgroundColor: "#022149",
              borderColor: "#022149",
              color: "#FCFCFC",
            }}
            onClick={() => {
              router.push({
                pathname: "/dashboard/products",
              });
            }}
          >
            Create New
          </Button>
        </Box>
      )}
      {/* Dialog box for Save documents */}
      <Dialog
        open={openSaveDialog}
        onClose={handleCloseSaveDialog}
        className=""
        PaperProps={{
          component: "form",
          onSubmit: (event) => {
            event.preventDefault();
            const formData = new FormData(event.currentTarget);
            const formJson = Object.fromEntries(formData.entries());
            const updatedFileName = formJson.fileName;
            if (/^\s*$/.test(updatedFileName)) {
              activateSnackbar(
                "file name cann't be empty or contain only space.",
                "error"
              );
              return;
            }
            setFileName(updatedFileName);
          },
          style: { width: "500px" },
        }}
      >
        <DialogTitle>Save Document</DialogTitle>
        <DialogContent>
          <DialogContentText>Document Name</DialogContentText>
          <TextField
            autoFocus
            required
            margin="dense"
            id="fileName"
            name="fileName"
            label="Example_Product_Upload.xls"
            type="text"
            defaultValue={saveFileName}
            // size="normal"
            fullWidth
            variant="standard"
          />
        </DialogContent>
        <DialogActions>
          <Button disableFocusRipple variant="contained" type="submit">
            Save
          </Button>
        </DialogActions>
      </Dialog>
      {/*Edit product pop up component*/}
      <EditProductDialog
        openEditProductDialog={openEditProductDialog}
        handleCloseSaveDialog={handleCloseSaveDialog}
        editableRow={editableRow}
        setEditableRow={setEditableRow}
        rowData={rowData}
        handleTextFieldChange={handleTextFieldChange}
        newRow={newRow}
        setNewRow={setNewRow}
        selectedProduct={selectedProduct}
        setSelectedProduct={setSelectedProduct}
        isResultPage={true}
        setIsValidProduct={setIsValidProduct}
        setAutoSave={setAutoSave}
        autoSave={autoSave}
        setCurrentProductIndex={setCurrentProductIndex}
        currentProductIndex={currentProductIndex}
        isSelected={isSelected}
      />
      {/* product table  */}
      {isSelected == "product" && !isLoading && (
        <PersonaTable
          tableData={newRow}
          setNewRow={setNewRow}
          setSelectedProduct={setSelectedProduct}
          selectedProduct={selectedProduct}
          handleRowClick={handleRowClick}
          editableRow={editableRow}
          isResultPage={true}
          isTaxonomy={isTaxonomy}
          isSEO={isSEO}
        />
      )}
      {/* Image Rec table  */}
      {isSelected == "image" && !isLoading && (
        <ImagePersonaTable
          tableData={newRow}
          setNewRow={setNewRow}
          setSelectedProduct={setSelectedProduct}
          selectedProduct={selectedProduct}
          handleRowClick={handleRowClick}
          editableRow={editableRow}
          isResultPage={true}
          isTaxonomy={isTaxonomy}
          isSEO={isSEO}
        />
      )}
      <SnackbarNotifier
        open={snackbarState.open}
        onClose={() => setSnackbarState({ ...snackbarState, open: false })}
        message={snackbarState.message}
        severity={snackbarState.severity}
      />
      <Snackbar
        anchorOrigin={{
          vertical: "top",
          horizontal: "center",
        }}
        open={isGenerateErrorOpen}
        autoHideDuration={10000}
        onClose={handleSnackbarClose}
      >
        <Alert severity="error" onClose={handleSnackbarClose}>
          <AlertTitle>Error</AlertTitle>
          {"Enter all the mandatory fields data"}
        </Alert>
      </Snackbar>
      <Snackbar
        anchorOrigin={{
          vertical: "top",
          horizontal: "center",
        }}
        open={isValidColumnName}
        autoHideDuration={10000}
        onClose={handleSnackbarClose}
      >
        <Alert severity="error" onClose={handleSnackbarClose}>
          <AlertTitle>Error</AlertTitle>
          {"Please provide valid column names"}
        </Alert>
      </Snackbar>
    </>
  );
};

export default products;

export async function getServerSideProps(context) {
  const session = await getSession(context);
  if (!session) {
    return {
      redirect: {
        destination: "/login",
      },
    };
  }
  const { name } = context.query;
  const user = session.user;

  return {
    props: {
      getFileName: name || "", // Ensure getFileName is defined
      user,
    },
  };
}
